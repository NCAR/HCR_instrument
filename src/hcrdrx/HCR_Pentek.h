// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
// ** Copyright UCAR (c) 2018-2021
// ** University Corporation for Atmospheric Research (UCAR)
// ** National Center for Atmospheric Research (NCAR)
// ** Boulder, Colorado, USA
// ** BSD licence applies - redistribution and use in source and binary
// ** forms, with or without modification, are permitted provided that
// ** the following conditions are met:
// ** 1) If the software is modified to produce derivative works,
// ** such modified software should be clearly marked, so as not
// ** to confuse it with the version available from UCAR.
// ** 2) Redistributions of source code must retain the above copyright
// ** notice, this list of conditions and the following disclaimer.
// ** 3) Redistributions in binary form must reproduce the above copyright
// ** notice, this list of conditions and the following disclaimer in the
// ** documentation and/or other materials provided with the distribution.
// ** 4) Neither the name of UCAR nor the names of its contributors,
// ** if any, may be used to endorse or promote products derived from
// ** this software without specific prior written permission.
// ** DISCLAIMER: THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS
// ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
// ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*

/*
 * HCR_Pentek.h
 *
 *  Created on: Apr 3, 2018
 *      Author: Chris Burghart <burghart@ucar.edu>
 */

#ifndef HCR_PENTEK_H_
#define HCR_PENTEK_H_

#include "HcrDrxConfig.h"
#include "IwrfExport.h"
#include "RadarController.h"
#include "PulseData.h"
#include "DrxStatus.h"
#include <ctime>
#include <vector>
#include <complex>
#include <Pentek_xx821.h>
#include <QtCore/QMutex>
#include <QtCore/QSharedPointer>
#include <QtCore/QSocketNotifier>
#include <QtCore/QThread>

/// @brief Subclass of Pentek_xx821 with specializations used for the Pentek boards
class HCR_Pentek: public QObject, Pentek_xx821 {
    Q_OBJECT
public:
    /// @brief HCR_Pentek constructor
    /// @param config object containing the configuration information
    /// @param boardNum number of the xx821 board to open (1 = first board,
    /// 2 = second board, etc.)
    /// @throws ConstructError on error in construction
    HCR_Pentek(const HcrDrxConfig & config,
                uint boardNum);
    virtual ~HCR_Pentek();

    /// @brief Return a string with information about the board and
    /// configuration
    /// @return a string with information about the board and configuration
    virtual std::string boardInfoString() const;

    /// @brief Register the IwrfExport instance
    /// @param exporter pointer to an IwrfExport object for publishing
    /// IWRF time series data (NULL if data will not be published)
    void setExporter(IwrfExport * exporter) {_exporter = exporter;}

    /// @brief Return the sample frequency used for the ADCs
    /// @return the sample frequency used for the ADCs
    double adcFrequency() const {
        return _config.clock_mode_125() ? 125e6 : 140.625e6;
    }

    /// @brief Return the frequency of samples emitted by the DACs
    /// @return the frequency of samples emitted by the DACs
    double dacFrequency() const {
        return _config.clock_mode_125() ? 500e6 : 562.5e6;
    }

    /// @brief Return the amount of DDC decimation
    /// @return the amount of DDC decimation
    int ddcDecimation() const {
        return _config.clock_mode_125() ? 8 : 9;
    }

    /// @brief Return the amount of DUC interpolation
    /// @return the amount of DUC interpolation
    int ducInterpolation() const {
        return _config.clock_mode_125() ? 2 : 4;
    }

    /// @brief Return the Pentek board clock frequency
    ///
    /// The DAC clock is generated by dividing down from the board clock
    /// frequency, so the board clock *must* be an integer multiple of the
    /// DAC frequency. For simplicity, we just set the board clock frequency
    /// to the DAC frequency.
    ///
    /// @return the Pentek board clock frequency
    double boardClockFrequency() const {
        return(dacFrequency());
    }

    /// @brief Change the schedule that the controller is running
    /// @param scheduleStartIndex first pulse block definition in the schedule
    /// @param scheduleStopIndex last pulse block definition in the schedule
    void changeControllerSchedule(uint32_t scheduleStartIndex, uint32_t scheduleStopIndex);

    /// @brief Zero the rot/tilt motor counts
    void zeroMotorCounts();

    /// @brief Return the current status
    DrxStatus status();

signals:
    /// @brief Signal emitted with data delivered for one of our ADC channels
    /// @param dmaStatus the Navigator status bitmap for the DMA transfer
    /// @param chan the ADC channel associated with the DMA transfer
    /// @param dataPtr shared pointer to the data buffer for the completed DMA
    /// link.
    /// @param metaDataPtr shared pointer to the metadata buffer for the
    /// completed DMA link.
    void newAdcData(int32_t chan,
                    int32_t dmaStatus,
                    QSharedPointer<uint8_t> const dataPtr,
                    QSharedPointer<NAV_DMA_ADC_META_DATA> const metaDataPtr);

    /// @brief Signal emitted upon DMA overrun
    ///
    /// Note that we handle DMA overruns via signal/slot because the overruns
    /// are first detected in AdcDmaCallbackHandler(), which always executes
    /// within a Navigator DMA thread. We cannot call NAV_DmaStop() from
    /// a Navigator DMA thread due to deadlock, so we instead emit this signal
    /// and connect it to a slot which will execute in the main thread.
    ///
    /// @param chan the ADC channel associated with the DMA overrun
    void adcDmaOverrun(int32_t chan);

    /// @brief Signal emitted upon DMA timeout
    ///
    /// Note that we handle DMA timeouts via signal/slot because the timeouts
    /// are first detected in AdcDmaCallbackHandler(), which always executes
    /// within a Navigator DMA thread. We cannot call NAV_DmaStop() from
    /// a Navigator DMA thread due to deadlock, so we instead emit this signal
    /// and connect it to a slot which will execute in the main thread.
    ///
    /// @param chan the ADC channel associated with the DMA timeout
    void adcDmaTimeout(int32_t chan);

private slots:
    /// @brief Callback handler for data delivered for one of our ADC channels
    /// @param dmaStatus the Navigator status bitmap for the DMA transfer
    /// @param chan the ADC channel associated with the DMA transfer
    /// @param dataPtr shared pointer to the data buffer for the completed DMA
    /// link.
    /// @param metaDataPtr shared pointer to the metadata buffer for the
    /// completed DMA link.
    void _acceptAdcData(int32_t chan,
                        int32_t dmaStatus,
                        QSharedPointer<uint8_t> const dataPtr,
                        QSharedPointer<NAV_DMA_ADC_META_DATA> const metaDataPtr);

    /// @brief Handler for ADC DMA overruns
    /// @param chan the ADC channel associated with the DMA overrun
    void _dmaOverrunHandler(int32_t chan);

    /// @brief Handler for ADC DMA timeouts
    /// @param chan the ADC channel associated with the DMA timeout
    void _dmaTimeoutHandler(int32_t chan);

public slots:

    /// @brief Halt and close the Pentek
    void quit();

private:

    /// @brief AXI base address for the general purpose registers in user block 2
    static constexpr uint32_t BLOCK2_GPR_BASE = 0x03800000;

    /// @brief AXI base address for the (in this case only) instance of the controller
    static constexpr uint32_t CONTROLLER_BASE = 0x03900000;

    typedef RadarController<HCR_Pentek> Controller;
    friend class RadarController<HCR_Pentek>;

    /// @brief Instance of the radar controller FPGA object
    Controller _controller;

    /// @brief Set up board basics for Navigator
    ///
    /// This method is only called from the constructor. It configures bus,
    /// clock, sync, gate, and PPS receive source parameters for the board.
    void _setupBoard() const;

    /// @brief Set up ADC channels
    ///
    /// This method is only called from the constructor.
    void _setupAdc();

    /// @brief Set up DDC channels
    ///
    /// This method is only called from the constructor.
    void _setupDdc();

    /// @brief Set up transmit: DAC, DUC, and waveforms
    ///
    /// This method is only called from the constructor.
    void _setupTx();

    /// @brief Helper function to define a pulse block from radar parameters
    Controller::PulseBlockDefinition _definePulseBlock(
        double  txPulseWidth,
        uint    numRxGates,
        uint    numPulses,
        double  prt1,
        double  prt2,
        double  blockPostTime,
        uint    filterSelect,
        Controller::PolarizationModes polMode,
        uint    phaseTableBegin,
        uint    phaseTableEnd
    );

    /// @brief Helper function to define a pulse block from a QJsonObject
    Controller::PulseBlockDefinition _definePulseBlock(
        const QJsonObject& pulseBlockDef,
        const QJsonObject& defaultDef = {}
    );

    /// @brief Set up the radar controller
    ///
    /// This method is only called from the constructor.
    void _setupController();

    /// @brief Start the radar
    ///
    /// This method is only called from the constructor.
    void _startRadar();

    /// @brief Log differences between current clock configuration and the
    /// clock frequency values to be loaded.
    void _logClockConfigDiffs() const;

    /// @brief Load FIR filter coefficients from the named file into
    /// the given coefficient vector.
    /// @param path the name of the coefficients file
    /// @param coefs the vector to be loaded with the coefficients
    static void ReadFilterCoefsFromFile(std::string path,
                                        std::vector<double> & coefs);

    /// @brief Load coefficients from the named file into
    /// the given coefficient vector.
    /// @param path the name of the coefficients file
    /// @param coefs the vector to be loaded with the coefficients
    static void ReadComplexCoefsFromFile(std::string path,
                                         std::vector<std::complex<int16_t>> & coefs);

    /// @brief Static function for DMA transfer callbacks from Navigator with
    /// ADC data.
    ///
    /// This method follows the signature defined by Navigator's dmaCallback_t
    /// function type. The implementation extracts the associated HCR_Pentek
    /// instance passed in userData, and calls that instance's
    /// _adcDmaCallbackHandler().
    ///
    /// @param channel the ADC channel returning data
    /// @param dmaStatus the Navigator status bitmap for the DMA transfer
    /// @param dataBuffer pointer to the data buffer for the completed DMA
    /// link. Will be NULL if DMA has timed out.
    /// @param metaDataBuffer pointer to the metadata buffer for the completed
    /// DMA link. Will be NULL if metadata is not being used or if the DMA has
    /// timed out.
    /// @param userData pointer to the user data, specified in NAV_DMASetup()
    static void AdcDmaCallbackHandler(int32_t channel, int32_t dmaStatus,
                                      void *dataBuffer, void *metaDataBuffer,
                                      void *userData);

    /// @brief Check the DMA metadata
    /// @param chan the ADC channel
    /// @param metadata pointer to the latest metadata from the channel
    /// @return True iff the metadata are usable
    bool _checkDmaMetadata(int chan, const NAV_DMA_ADC_META_DATA * metadata);

    /// @brief Convert seconds to scheduler counts
    uint32_t _counts(double seconds) { return std::round(seconds * adcFrequency()); }

    /// @brief Convert scheduler counts to seconds
    double _fromCounts(double counts) { return counts / adcFrequency(); }

    /// @brief HCR configuration
    const HcrDrxConfig & _config;

    /// @brief Radar start time, seconds since 1970-01-01 00:00:00 UTC
    time_t _radarStartSecond;

    /// @brief Number dropped RX DMA packets
    std::vector<uint32_t> _dmaPacketsDropped;

    /// @brief If true, enable the digital downconverter
    bool _ddcEnable;

    /// @brief The pulse sequencer definitions that describe the radar timeline
    std::vector<Controller::PulseBlockDefinition> _pulseBlockDefinitions;

    /// @brief IwrfPublisher instance for publishing short-pulse IWRF time
    /// series data
    IwrfExport * _exporter;

    /// @brief Continuous wave (CW) filter real coefficients by DDC channel
    std::map<uint, std::vector<int32_t> > _cwFilterCoefs;

    /// @brief DMA packet number from last received packet on each ADC channel
    std::vector<int32_t> _prevDmaPacketNum;

    /// @brief Number of DMA packets dropped before we see the metadata
    /// signature of first good data after a reconfiguration, i.e., PPS count 0
    /// and TQS count 1.
    std::vector<uint32_t> _nDroppedBeforeStartSig;

    /// @brief Unprocessed DMA count at last interrupt
    std::vector<int32_t> _unprocessedDma;

    /// @brief Max unprocessed DMA count
    std::vector<int32_t> _maxUnprocessedDma;

    /// @brief Socket notifier for console input
    QSocketNotifier _consoleNotifier;

    /// @brief Number of pulses processed
    std::vector<int64_t> _processedPulses;

    /// @brief List of schedules that have been defined for use
    std::vector<OperationMode> _supportedOpsModes;

    std::vector<IwrfExport::DataChannelType> _chanType;
    std::vector<PulseData*> _pulseData;
    std::vector<uint64_t> _prevPulseSeq;
    double _digitizerSampleWidth;
    bool _done;

    double _prevXmitPulseWidth;
    double _prevPrt;
    uint16_t _prevnGates;
    bool _motorZeroPositionSet;
    double _fpgaTemp;
    double _localTemp;

    /// @brief Firmware build to check for.
    const uint32_t COMPATIBLE_FIRMWARE_DATE = 0x20230417;
    const uint16_t COMPATIBLE_FIRMWARE_HOUR = 0x10;

};


#endif /* HCR_PENTEK_H_ */
