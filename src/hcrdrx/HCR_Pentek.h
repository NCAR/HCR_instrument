// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
// ** Copyright UCAR (c) 2018-2021
// ** University Corporation for Atmospheric Research (UCAR)
// ** National Center for Atmospheric Research (NCAR)
// ** Boulder, Colorado, USA
// ** BSD licence applies - redistribution and use in source and binary
// ** forms, with or without modification, are permitted provided that
// ** the following conditions are met:
// ** 1) If the software is modified to produce derivative works,
// ** such modified software should be clearly marked, so as not
// ** to confuse it with the version available from UCAR.
// ** 2) Redistributions of source code must retain the above copyright
// ** notice, this list of conditions and the following disclaimer.
// ** 3) Redistributions in binary form must reproduce the above copyright
// ** notice, this list of conditions and the following disclaimer in the
// ** documentation and/or other materials provided with the distribution.
// ** 4) Neither the name of UCAR nor the names of its contributors,
// ** if any, may be used to endorse or promote products derived from
// ** this software without specific prior written permission.
// ** DISCLAIMER: THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS
// ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
// ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
// *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*

/*
 * HCR_Pentek.h
 *
 *  Created on: Apr 3, 2018
 *      Author: Chris Burghart <burghart@ucar.edu>
 */

#ifndef HCR_PENTEK_H_
#define HCR_PENTEK_H_

#include "HCR_Config.h"
#include "HCR_Beam.h"
#include "IwrfPublisher.h"
#include "RadarController.h"
#include <ctime>
#include <vector>
#include <complex>
#include <Pentek_xx821.h>
#include <QtCore/QMutex>
#include <QtCore/QSharedPointer>
#include <QtCore/QSocketNotifier>
#include <QtCore/QThread>

/// @brief Subclass of Pentek_xx821 with specializations used for the Pentek boards
class HCR_Pentek: public QObject, Pentek_xx821 {
    Q_OBJECT
public:
    /// @brief HCR_Pentek constructor
    /// @param config object containing the configuration information
    /// @param boardNum number of the xx821 board to open (1 = first board,
    /// 2 = second board, etc.)
    /// @param longPublisher pointer to an IwrfPublisher object for publishing
    /// long-pulse IWRF time series data (NULL if data will not be published)
    /// @param shortPublisher pointer to an IwrfPublisher object for publishing
    /// short-pulse IWRF time series data (NULL if data will not be published)
    /// @throws ConstructError on error in construction
    HCR_Pentek(const HCR_Config & config,
                uint boardNum,
                IwrfPublisher * longPublisher,
                IwrfPublisher * shortPublisher);
    virtual ~HCR_Pentek();

    /// @brief Base clock frequency for HCR
    static constexpr double BASE_FREQUENCY = 200.0e6;

    /// @brief Reference clock frequency provided to the Pentek board
    static constexpr double REF_FREQUENCY = 10.0e6;
    
    /// @brief Receive DDC decimation setting
    static constexpr int DDC_DECIMATION = 8;

    /// @brief Return a string with information about the board and
    /// configuration
    /// @return a string with information about the board and configuration
    virtual std::string boardInfoString() const;

    /// @brief Return the sample frequency used for the ADCs
    /// @return the sample frequency used for the ADCs
    double adcFrequency() const {
        // We run the ADCs at BASE_FREQUENCY
        return(BASE_FREQUENCY);
    }

    /// @brief Return the frequency of samples emitted by the DACs
    ///
    /// The DACs are set up to deliver interpolated samples from the
    /// digital upconverter (DUC) at a chosen multiple of BASE_FREQUENCY.
    ///
    /// @return the frequency of samples emitted by the DACs
    double dacFrequency() const {
        //return(BASE_FREQUENCY * _config.duc_interpolation());
        return(BASE_FREQUENCY); //For HCR I think we just want a common clock
    }

    /// @brief Return the Pentek board clock frequency
    ///
    /// The DAC clock is generated by dividing down from the board clock
    /// frequency, so the board clock *must* be an integer multiple of the
    /// DAC frequency. For simplicity, we just set the board clock frequency
    /// to the DAC frequency.
    ///
    /// @return the Pentek board clock frequency
    double boardClockFrequency() const {
        return(dacFrequency());
    }

    /// @brief Return the digitizer sample width for the selected ADC channel, s
    /// @param adcChan the ADC channel of interest
    /// @return the digitizer sample width for the selected ADC channel, s
    double digitizer_sample_width(int adcChan) const {
        return(DDC_DECIMATION / BASE_FREQUENCY);
    }

signals:
    /// @brief Signal emitted with data delivered for one of our ADC channels
    /// @param dmaStatus the Navigator status bitmap for the DMA transfer
    /// @param chan the ADC channel associated with the DMA transfer
    /// @param dataPtr shared pointer to the data buffer for the completed DMA
    /// link.
    /// @param metaDataPtr shared pointer to the metadata buffer for the
    /// completed DMA link.
    void newAdcData(int32_t chan,
                    int32_t dmaStatus,
                    QSharedPointer<uint8_t> const dataPtr,
                    QSharedPointer<NAV_DMA_ADC_META_DATA> const metaDataPtr);

    /// @brief Signal emitted upon DMA overrun
    ///
    /// Note that we handle DMA overruns via signal/slot because the overruns
    /// are first detected in AdcDmaCallbackHandler(), which always executes
    /// within a Navigator DMA thread. We cannot call NAV_DmaStop() from
    /// a Navigator DMA thread due to deadlock, so we instead emit this signal
    /// and connect it to a slot which will execute in the main thread.
    ///
    /// @param chan the ADC channel associated with the DMA overrun
    void adcDmaOverrun(int32_t chan);

    /// @brief Signal emitted upon DMA timeout
    ///
    /// Note that we handle DMA timeouts via signal/slot because the timeouts
    /// are first detected in AdcDmaCallbackHandler(), which always executes
    /// within a Navigator DMA thread. We cannot call NAV_DmaStop() from
    /// a Navigator DMA thread due to deadlock, so we instead emit this signal
    /// and connect it to a slot which will execute in the main thread.
    ///
    /// @param chan the ADC channel associated with the DMA timeout
    void adcDmaTimeout(int32_t chan);

private slots:
    /// @brief Callback handler for data delivered for one of our ADC channels
    /// @param dmaStatus the Navigator status bitmap for the DMA transfer
    /// @param chan the ADC channel associated with the DMA transfer
    /// @param dataPtr shared pointer to the data buffer for the completed DMA
    /// link.
    /// @param metaDataPtr shared pointer to the metadata buffer for the
    /// completed DMA link.
    void _acceptAdcData(int32_t chan,
                        int32_t dmaStatus,
                        QSharedPointer<uint8_t> const dataPtr,
                        QSharedPointer<NAV_DMA_ADC_META_DATA> const metaDataPtr);

    /// @brief Handler for ADC DMA overruns
    /// @param chan the ADC channel associated with the DMA overrun
    void _dmaOverrunHandler(int32_t chan);

    /// @brief Handler for ADC DMA timeouts
    /// @param chan the ADC channel associated with the DMA timeout
    void _dmaTimeoutHandler(int32_t chan);

private:

    /// @brief AXI base address for the general purpose registers in user block 2
    static constexpr uint32_t BLOCK2_GPR_BASE = 0x03800000;

    /// @brief AXI base address for the (in this case only) instance of the controller
    static constexpr uint32_t CONTROLLER_BASE = 0x03900000;

    typedef RadarController<HCR_Pentek> Controller;
    friend class RadarController<HCR_Pentek>;
    
    /// @brief Instance of the radar controller FPGA object
    Controller _controller;
    
    /// @brief Set up board basics for Navigator
    ///
    /// This method is only called from the constructor. It configures bus,
    /// clock, sync, gate, and PPS receive source parameters for the board.
    void _setupBoard() const;

    /// @brief Set up ADC channels
    ///
    /// This method is only called from the constructor.
    void _setupAdc();

    /// @brief Set up DDC channels
    ///
    /// This method is only called from the constructor.
    void _setupDdc();

    /// @brief Set up transmit: DAC, DUC, and waveforms
    ///
    /// This method is only called from the constructor.
    void _setupTx();
    
    /// @brief Set up the radar controller
    ///
    /// This method is only called from the constructor.
    void _setupController();    

    /// @brief Start the radar
    ///
    /// This method is only called from the constructor.
    void _startRadar();

    /// @brief Log differences between current clock configuration and the
    /// clock frequency values to be loaded.
    void _logClockConfigDiffs() const;

    /// @brief Load FIR filter coefficients from the named file into
    /// the given coefficient vector.
    /// @param path the name of the coefficients file
    /// @param coefs the vector to be loaded with the coefficients
    static void ReadFilterCoefsFromFile(std::string path,
                                        std::vector<double> & coefs);

    /// @brief Static function for DMA transfer callbacks from Navigator with
    /// ADC data.
    ///
    /// This method follows the signature defined by Navigator's dmaCallback_t
    /// function type. The implementation extracts the associated HCR_Pentek
    /// instance passed in userData, and calls that instance's
    /// _adcDmaCallbackHandler().
    ///
    /// @param channel the ADC channel returning data
    /// @param dmaStatus the Navigator status bitmap for the DMA transfer
    /// @param dataBuffer pointer to the data buffer for the completed DMA
    /// link. Will be NULL if DMA has timed out.
    /// @param metaDataBuffer pointer to the metadata buffer for the completed
    /// DMA link. Will be NULL if metadata is not being used or if the DMA has
    /// timed out.
    /// @param userData pointer to the user data, specified in NAV_DMASetup()
    static void AdcDmaCallbackHandler(int32_t channel, int32_t dmaStatus,
                                      void *dataBuffer, void *metaDataBuffer,
                                      void *userData);

    /// @brief Check the DMA metadata
    /// @param chan the ADC channel
    /// @param metadata pointer to the latest metadata from the channel
    /// @return True iff the metadata are usable
    bool _checkDmaMetadata(int chan, const NAV_DMA_ADC_META_DATA * metadata);

    /// @brief HCR configuration
    const HCR_Config & _config;

    /// @brief Radar start time, seconds since 1970-01-01 00:00:00 UTC
    time_t _radarStartSecond;

    /// @brief Number dropped RX DMA packets
    std::vector<uint32_t> _dmaPacketsDropped;
    
    /// @brief If true, enable the digital downconverter
    bool _ddcEnable;
    
    /// @brief The pulse sequencer definitions that describe the radar timeline
    std::vector<Controller::PulseDefinition> _pulseDefinitions;

    /// @brief IwrfPublisher instance for publishing long-pulse IWRF time
    /// series data
    IwrfPublisher * _longPublisher;

    /// @brief IwrfPublisher instance for publishing short-pulse IWRF time
    /// series data
    IwrfPublisher * _shortPublisher;

    /// @brief Continuous wave (CW) filter real coefficients by DDC channel
    std::map<uint, std::vector<int32_t> > _cwFilterCoefs;

    /// @brief DMA packet number from last received packet on each ADC channel
    std::vector<int32_t> _prevDmaPacketNum;

    /// @brief Number of DMA packets dropped before we see the metadata
    /// signature of first good data after a reconfiguration, i.e., PPS count 0
    /// and TQS count 1.
    std::vector<uint32_t> _nDroppedBeforeStartSig;

    /// @brief Unprocessed DMA count at last interrupt
    std::vector<int32_t> _unprocessedDma;

    /// @brief Max unprocessed DMA count
    std::vector<int32_t> _maxUnprocessedDma;

    /// @brief Socket notifier for console input
    QSocketNotifier _consoleNotifier;

};


#endif /* HCR_PENTEK_H_ */
