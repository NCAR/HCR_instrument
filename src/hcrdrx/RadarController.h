
#ifndef RADAR_CONTROLLER_H_
#define RADAR_CONTROLLER_H_


// The raw (XHCR) definitions are autogenerated.
// To update them, copy xhcr_controller_hw.h from the HLS IP
// (please don't edit manually)
#include "xhcr_controller_hw.h"
#include <vector>

/// @brief Radar controller FPGA block
/// Usable by any class 'FPGA' that implements writeLiteRegister_ and readLiteRegister_
template<typename FPGA> class RadarController {

public:

    RadarController(const FPGA& fpgaInstance, uint32_t baseAddr) : fpga(fpgaInstance), base(baseAddr) {};

    struct PulseBlockDefinition
    {
        uint32_t prt[2];            // Pulse repetition time(s) in cycles. Set unused PRTs to 0
        uint32_t numPulses;         // Generate this many pulses
        uint32_t blockPostTime;     // Time at the end of the group of pulses, in cycles
        uint32_t controlFlags;      // Set the CONTROL_FLAGS output to this value
        uint32_t polarizationMode;  // Set the polarization mode
        uint32_t filterSelectCh0;   // Select this filter for ADC channel 0
        uint32_t filterSelectCh1;   // Select this filter for ADC channel 1
        uint32_t filterSelectCh2;   // Select this filter for ADC channel 2
        struct
        {
            uint32_t offset;        // First, wait this many cycles before setting MT_PULSE[n]
            uint32_t width;         // Then, wait this many cycles before clearing MT_PULSE[n]
        } timers[8];
    };

    struct PulseHeader
    {
        uint32_t magic;
        struct
        {
            unsigned int HV                 : 1;
            unsigned int spare0             : 15;
            unsigned int firstPulseInBlock  : 1;
            unsigned int lastPulseInBlock   : 1;
            unsigned int firstPulseInXfer   : 1;
            unsigned int lastPulseInXfer    : 1;
            unsigned int spare1             : 12;
        } statusFlags;
        uint32_t posEnc0;
        uint32_t posEnc1;
        uint32_t pulseBlockDefinitionNumber;
        uint32_t numSamples;
        uint32_t prt;
        uint32_t spare7;
        uint64_t pulseSequenceNumber;
        uint32_t spare10;
        uint32_t spare11;
        uint32_t spare12;
        uint32_t spare13;
        uint32_t spare14;
        uint32_t spare15;
    };

    static constexpr uint32_t NUM_PULSE_SEQUENCE_DEFINITIONS          = XHCR_CONTROLLER_CFG_BUS_DEPTH_CFG_PULSE_SEQUENCE_PRT_0;
    static constexpr uint32_t NUM_TOTAL_FILTER_COEFS                  = XHCR_CONTROLLER_CFG_BUS_DEPTH_CFG_FILTER_COEFS_CH0;
    static constexpr uint32_t NUM_FILTER_COEF_SETS                    = 8;
    static constexpr uint32_t INFINITE_PULSES                         = 0;
    static constexpr uint32_t HEADER_MAGIC                            = 0xba5eba11;

    enum Timers {
        MASTER_SYNC, // timer 0 is the master sync timer
        RX_0,        // timer 1 is the rx timer for channel 0
        RX_1,        // timer 2 is the rx timer for channel 1
        RX_2,        // timer 3 is the rx timer for channel 2
        TX_PULSE,    // timer 4 is the tx pulse timer
        MOD_PULSE,   // timer 5 is the mod pulse
        EMS_TRIG,    // timer 6 is the EMS trigger
        TIMER_7      // timer 7 is spare
    };

    enum PolarizationModes {
        POL_MODE_V,
        POL_MODE_H,
        POL_MODE_HHVV
    };

private :

    enum RegDefs : uint32_t {
        CTRL                                    = XHCR_CONTROLLER_CFG_BUS_ADDR_AP_CTRL,
        GIE                                     = XHCR_CONTROLLER_CFG_BUS_ADDR_GIE,
        IER                                     = XHCR_CONTROLLER_CFG_BUS_ADDR_IER,
        ISR                                     = XHCR_CONTROLLER_CFG_BUS_ADDR_ISR,
        PULSE_SEQUENCE_START_STOP_INDEXES       = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_PULSE_SEQUENCE_START_STOP_INDEXES_DATA,
        NUM_PULSES_TO_EXECUTE                   = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_NUM_PULSES_TO_EXECUTE_DATA,
        TOTAL_DECIMATION                        = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_TOTAL_DECIMATION_DATA,
        POST_DECIMATION                         = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_POST_DECIMATION_DATA,
        NUM_PULSES_PER_XFER                     = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_NUM_PULSES_PER_XFER_DATA,
        ENABLED_CHANNEL_VECTOR                  = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_ENABLED_CHANNEL_VECTOR_DATA,
        PULSE_SEQUENCE_PRT_0                    = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_PULSE_SEQUENCE_PRT_0_BASE,
        PULSE_SEQUENCE_PRT_1                    = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_PULSE_SEQUENCE_PRT_1_BASE,
        PULSE_SEQUENCE_NUM_PULSES               = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_PULSE_SEQUENCE_NUM_PULSES_BASE,
        PULSE_SEQUENCE_BLOCK_POST_TIME          = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_PULSE_SEQUENCE_BLOCK_POST_TIME_BASE,
        PULSE_SEQUENCE_CONTROL_FLAGS            = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_PULSE_SEQUENCE_CONTROL_FLAGS_BASE,
        PULSE_SEQUENCE_POLARIZATION_MODE        = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_PULSE_SEQUENCE_POLARIZATION_MODE_BASE,
        PULSE_SEQUENCE_FILTER_SELECT_CH0        = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_PULSE_SEQUENCE_FILTER_SELECT_CH0_BASE,
        PULSE_SEQUENCE_FILTER_SELECT_CH1        = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_PULSE_SEQUENCE_FILTER_SELECT_CH1_BASE,
        PULSE_SEQUENCE_FILTER_SELECT_CH2        = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_PULSE_SEQUENCE_FILTER_SELECT_CH2_BASE,
        PULSE_SEQUENCE_TIMER_OFFSET_0           = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_PULSE_SEQUENCE_TIMER_OFFSET_0_BASE,
        PULSE_SEQUENCE_TIMER_OFFSET_1           = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_PULSE_SEQUENCE_TIMER_OFFSET_1_BASE,
        PULSE_SEQUENCE_TIMER_OFFSET_2           = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_PULSE_SEQUENCE_TIMER_OFFSET_2_BASE,
        PULSE_SEQUENCE_TIMER_OFFSET_3           = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_PULSE_SEQUENCE_TIMER_OFFSET_3_BASE,
        PULSE_SEQUENCE_TIMER_OFFSET_4           = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_PULSE_SEQUENCE_TIMER_OFFSET_4_BASE,
        PULSE_SEQUENCE_TIMER_OFFSET_5           = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_PULSE_SEQUENCE_TIMER_OFFSET_5_BASE,
        PULSE_SEQUENCE_TIMER_OFFSET_6           = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_PULSE_SEQUENCE_TIMER_OFFSET_6_BASE,
        PULSE_SEQUENCE_TIMER_OFFSET_7           = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_PULSE_SEQUENCE_TIMER_OFFSET_7_BASE,
        PULSE_SEQUENCE_TIMER_WIDTH_0            = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_PULSE_SEQUENCE_TIMER_WIDTH_0_BASE,
        PULSE_SEQUENCE_TIMER_WIDTH_1            = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_PULSE_SEQUENCE_TIMER_WIDTH_1_BASE,
        PULSE_SEQUENCE_TIMER_WIDTH_2            = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_PULSE_SEQUENCE_TIMER_WIDTH_2_BASE,
        PULSE_SEQUENCE_TIMER_WIDTH_3            = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_PULSE_SEQUENCE_TIMER_WIDTH_3_BASE,
        PULSE_SEQUENCE_TIMER_WIDTH_4            = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_PULSE_SEQUENCE_TIMER_WIDTH_4_BASE,
        PULSE_SEQUENCE_TIMER_WIDTH_5            = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_PULSE_SEQUENCE_TIMER_WIDTH_5_BASE,
        PULSE_SEQUENCE_TIMER_WIDTH_6            = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_PULSE_SEQUENCE_TIMER_WIDTH_6_BASE,
        PULSE_SEQUENCE_TIMER_WIDTH_7            = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_PULSE_SEQUENCE_TIMER_WIDTH_7_BASE,
        FILTER_COEFS_CH0                        = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_FILTER_COEFS_CH0_BASE,
        FILTER_COEFS_CH1                        = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_FILTER_COEFS_CH1_BASE,
        FILTER_COEFS_CH2                        = XHCR_CONTROLLER_CFG_BUS_ADDR_CFG_FILTER_COEFS_CH2_BASE
    };

    const FPGA& fpga;
    const uint32_t base;

    template<typename T> auto write_(uint32_t addr, T val, const std::string& action)
    {
        return fpga.writeLiteRegister_(base+addr, val, action);
    };

    auto read_(uint32_t addr, const std::string& action)
    {
        return fpga.readLiteRegister_(base+addr, action);
    };

public:

    void writePulseBlockDefinition(const PulseBlockDefinition& blockDef, size_t index)
    {
        if (index>=NUM_PULSE_SEQUENCE_DEFINITIONS)
            throw std::runtime_error("Too many pulse definitions");

        //These checks are HCR-specific. They avoid drifting relative to the 156.25MHz IF
        if (blockDef.prt[0] % 8 != 0)
            throw std::runtime_error("PRT0 must be a multiple of 64ns");

        if (blockDef.prt[1] % 8 != 0)
            throw std::runtime_error("PRT1 must be a multiple of 64ns");

        if (blockDef.blockPostTime % 8 != 0)
            throw std::runtime_error("Post-time must be a multiple of 64ns");

        const std::string action = "Writing pulse definition";
        write_(index*sizeof(uint32_t) + PULSE_SEQUENCE_PRT_0             , blockDef.prt[0],           action);
        write_(index*sizeof(uint32_t) + PULSE_SEQUENCE_PRT_1             , blockDef.prt[1],           action);
        write_(index*sizeof(uint32_t) + PULSE_SEQUENCE_NUM_PULSES        , blockDef.numPulses,        action);
        write_(index*sizeof(uint32_t) + PULSE_SEQUENCE_BLOCK_POST_TIME   , blockDef.blockPostTime,    action);
        write_(index*sizeof(uint32_t) + PULSE_SEQUENCE_CONTROL_FLAGS     , blockDef.controlFlags,     action);
        write_(index*sizeof(uint32_t) + PULSE_SEQUENCE_POLARIZATION_MODE , blockDef.polarizationMode, action);
        write_(index*sizeof(uint32_t) + PULSE_SEQUENCE_FILTER_SELECT_CH0 , blockDef.filterSelectCh0,  action);
        write_(index*sizeof(uint32_t) + PULSE_SEQUENCE_FILTER_SELECT_CH1 , blockDef.filterSelectCh1,  action);
        write_(index*sizeof(uint32_t) + PULSE_SEQUENCE_FILTER_SELECT_CH2 , blockDef.filterSelectCh2,  action);
        write_(index*sizeof(uint32_t) + PULSE_SEQUENCE_TIMER_OFFSET_0    , blockDef.timers[0].offset, action);
        write_(index*sizeof(uint32_t) + PULSE_SEQUENCE_TIMER_OFFSET_1    , blockDef.timers[1].offset, action);
        write_(index*sizeof(uint32_t) + PULSE_SEQUENCE_TIMER_OFFSET_2    , blockDef.timers[2].offset, action);
        write_(index*sizeof(uint32_t) + PULSE_SEQUENCE_TIMER_OFFSET_3    , blockDef.timers[3].offset, action);
        write_(index*sizeof(uint32_t) + PULSE_SEQUENCE_TIMER_OFFSET_4    , blockDef.timers[4].offset, action);
        write_(index*sizeof(uint32_t) + PULSE_SEQUENCE_TIMER_OFFSET_5    , blockDef.timers[5].offset, action);
        write_(index*sizeof(uint32_t) + PULSE_SEQUENCE_TIMER_OFFSET_6    , blockDef.timers[6].offset, action);
        write_(index*sizeof(uint32_t) + PULSE_SEQUENCE_TIMER_OFFSET_7    , blockDef.timers[7].offset, action);
        write_(index*sizeof(uint32_t) + PULSE_SEQUENCE_TIMER_WIDTH_0     , blockDef.timers[0].width,  action);
        write_(index*sizeof(uint32_t) + PULSE_SEQUENCE_TIMER_WIDTH_1     , blockDef.timers[1].width,  action);
        write_(index*sizeof(uint32_t) + PULSE_SEQUENCE_TIMER_WIDTH_2     , blockDef.timers[2].width,  action);
        write_(index*sizeof(uint32_t) + PULSE_SEQUENCE_TIMER_WIDTH_3     , blockDef.timers[3].width,  action);
        write_(index*sizeof(uint32_t) + PULSE_SEQUENCE_TIMER_WIDTH_4     , blockDef.timers[4].width,  action);
        write_(index*sizeof(uint32_t) + PULSE_SEQUENCE_TIMER_WIDTH_5     , blockDef.timers[5].width,  action);
        write_(index*sizeof(uint32_t) + PULSE_SEQUENCE_TIMER_WIDTH_6     , blockDef.timers[6].width,  action);
        write_(index*sizeof(uint32_t) + PULSE_SEQUENCE_TIMER_WIDTH_7     , blockDef.timers[7].width,  action);
    };

    void writePulseBlockDefinitions(const std::vector<PulseBlockDefinition>& blockDefs, size_t startIndex = 0)
    {
        for (auto&& def : blockDefs) writePulseBlockDefinition(def, startIndex++);
    }

    void writeFilterCoefs(const std::vector<double>& coefs, int chan)
    {
        uint32_t base;
        switch (chan)
        {
            case 0: base=FILTER_COEFS_CH0; break;
            case 1: base=FILTER_COEFS_CH1; break;
            case 2: base=FILTER_COEFS_CH2; break;
            default: throw std::runtime_error("Wrong channel");
        }

        if(coefs.size() != NUM_TOTAL_FILTER_COEFS)
        {
            std::ostringstream os;
            os << "Writing pulse filter coefficients for channel "
               << chan << ": need " << NUM_TOTAL_FILTER_COEFS << " coefs, have " << coefs.size();
            throw(std::runtime_error(os.str()));
        }

        for(uint32_t index=0; index<NUM_TOTAL_FILTER_COEFS; index++)
        {
            int32_t intCoef = round(coefs[index]*0x400000);
            write_(index*sizeof(uint32_t) + base, intCoef, "Writing pulse coef");
        }
    }

    void changeSchedule(uint32_t sequenceStartIndex, uint32_t sequenceStopIndex)
    {
        // This will update the next time it loops throught the schedule
        write_(PULSE_SEQUENCE_START_STOP_INDEXES, (sequenceStopIndex<<16)|sequenceStartIndex,  "Writing controller sched index");
    }

    void run(   uint32_t sequenceStartIndex,
                uint32_t sequenceStopIndex,
                uint32_t ddcDecimation,
                uint32_t postDecimation,
                uint32_t numPulsesPerXfer,
                uint32_t enabledChannelVector,
                uint32_t numPulsesToExecute
            )
    {
        uint32_t totalDecimation = ddcDecimation * postDecimation;
        changeSchedule(sequenceStartIndex, sequenceStopIndex);
        write_(NUM_PULSES_TO_EXECUTE,      numPulsesToExecute,  "Writing num pulses to execute");
        write_(TOTAL_DECIMATION,           totalDecimation,     "Writing total decimation");
        write_(POST_DECIMATION,            postDecimation,      "Writing post decimation");
        write_(NUM_PULSES_PER_XFER,        numPulsesPerXfer,    "Writing num pulses per xfer");
        write_(ENABLED_CHANNEL_VECTOR,     enabledChannelVector,"Writing enabled channel vector");
        write_(CTRL,                       1,                   "Starting controller");
    };

    void halt()
    {
        // If not running, this has no effect.
        // If running, it will schedule at most one more pulse, check this limit, and finish.
        write_(NUM_PULSES_TO_EXECUTE, 1, "Writing num pulses to execute");

        // Spin until halted
        while ( ! (read_(CTRL, "Poll ap_idle bit") & 0x4) ) usleep(100);
    };

};

#endif // RADAR_CONTROLLER_H_


