//
//	Rotation Drive Functions
//

/////////////////////////////////////////////////////////////////////
function rotHoming()
	MO=0; UM=5;
	homing(80000);
return

/////////////////////////////////////////////////////////////////////
function rotInit()
	// Counts per full cycle (360 deg)
	int fullCycle;
	fullCycle = CA[18]*100;
	
	// Set AC and DC to 90 deg/s2
	AC=fullCycle/4; DC=AC;
	
	// Set counting range for the main feedback (PX)
	XM[1]=0; XM[2]=fullCycle;
	ER[3]=XM[2]/4-1;
	
	// Set speed (max speed is VH[2])
	SP=VH[2]*0.75;
	MO=1;
return

//
//	Tilt Drive Functions
//

/////////////////////////////////////////////////////////////////////
function tiltHoming()
	MO=0; UM=5;
	
	// For the tilt drive, the homing process must begin from the
	// right limit switch. If we're not at the RLS, move there now.
	// (IP bit 11 tells if we're at the RLS)
	if (! (IP & (1 << 11)))
		MO=1;
		// Stop at RLS
		HM[3]=7; HM[4]=0; HM[5]=2;
		HM[1]=1;
		JV=-10000; BG;
		waitHoming();
	end
	
	// KLUGE: When the tilt drive is at a limit switch, it sometimes also
	// indicates it is at the home position. This is incorrect! If the drive
	// now thinks it's at home position, move forward slightly to get off
	// of home. (The 'homing' function would also try to move us off of home,
	// but it tries to move backward, which can't happen because we just 
	// moved backward to the limit switch).
	//
  // Move forward a bit if we're currently on the home sensor (digital input 5)
  // (IP bit 20 tells the state of digital input 5)
  if (IP & (1 << 20))
    PR=2000; BG;
    waitMotion();
  end

  // Finally, we can begin the generic homing process.
	homing(10000);
return

/////////////////////////////////////////////////////////////////////
function tiltInit()
	// Counts per full cycle (360 deg)
	int fullCycle;
	fullCycle = CA[18]*240;
	
	// Set AC and DC to 90 deg/s2
	AC=fullCycle/4; DC=AC;
	
	// Set counting range for the main feedback (PX)
	XM[1]=-fullCycle/2; XM[2]=fullCycle/2;
	ER[3]=XM[2]/4-1;
	
	// Set speed (max speed is VH[2])
	SP=VH[2]*0.75;
	MO=1;
return


//
//	Shared Functions
//

/////////////////////////////////////////////////////////////////////
//
//	Put drive at a known position and set reference
//		- jvSpeed: the jogging velocity (counts/sec)
//
function homing(int jvSpeed)
	MO=1;

	// Back up a bit if we're currently on the home sensor (digital input 5)
	// (IP bit 20 tells the state of digital input 5)
	if (IP & (1 << 20))
		PR=-10000; BG;
		waitMotion();
	end

	// Jog forward and set zero absolute position where we first
	// see the home sensor. This position may vary a bit since the
	// home sensor for the rotation motor has a wide field of view.
	HM[2]=0; HM[3]=17; HM[4]=0; HM[5]=0;
	HM[1]=1;
	JV=jvSpeed; BG;
	waitHoming();
	
	// Back up to the zero mark we just set
	PA=0; BG;
	waitMotion();
	
	// Now jog to the first index mark forward of 'home' and move absolute 
	// zero location there. This position should be consistent.
	HM[2]=0; HM[3]=3; HM[4]=0; HM[5]=0;
	HM[1]=1;
	JV=jvSpeed; BG;
	waitHoming();
	
	// Move the drive back to our new zero
	PA=0; BG;
	waitMotion();
return

/////////////////////////////////////////////////////////////////////
//
// Wait until homing (and residual motion after homing) is complete
//
function waitHoming()
	while (HM[1])
		wait(5);
	end
	waitMotion();
return

/////////////////////////////////////////////////////////////////////
//
// Wait until motion completes
//
function waitMotion()
	// wait for motion to complete
	while (MS == 2)
		wait(5);
	end
return
